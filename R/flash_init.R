#' Initialize flash object
#'
#' Sets up a \code{\link{flash}} object with no factors. Since all other
#' \code{flash_xxx} functions take a \code{flash} or \code{flash_fit} object
#' as their first argument, calling \code{flash_init} should be the first step
#' in any \code{flash} pipeline. See \code{\link{flash}} for examples of usage.
#'
#' @inheritParams flash
#'
#' @param S_dim If the argument to \code{S} is a vector and the data matrix is
#'   square, then \code{S_dim} must specify whether \code{S} encodes row-wise or
#'   column-wise standard errors. More precisely,
#'   if \code{S_dim = 1}, then \code{S} will be interpreted as giving
#'   standard errors that vary across rows but are constant within any particular
#'   row; if \code{S_dim = 2}, then it will be interpreted as giving
#'   standard errors that vary across columns but are constant within any
#'   particular column. If \code{S} is a matrix or scalar, or if the data
#'   matrix is not square, then \code{S_dim} should be left unspecified
#'   (\code{NULL}).
#'
#' @param Y2 Optionally, users can supply a scalar \code{Y2} \eqn{=\sum_{i,j} y_{ij}^2},
#'   where \eqn{Y} is a data matrix for \code{data}. \code{Y2} is needed to  
#'   estimate the residual variance parameters \eqn{s_{ij}^2} when \code{var_type} 
#'   is set to 0. This can be particularly useful when \eqn{Y} has a low-rank 
#'   matrix representation, e.g., \eqn{Y = \frac{1}{p}XX'}, where \eqn{X} is a 
#'   \eqn{n \times p} sparse matrix and \eqn{p} is much smaller than \eqn{n}.
#'   In this case, users can directly supply \code{Y2} which can be calculated
#'   using the summed squared values of \eqn{\frac{1}{p}X'X} (see the example below), 
#'   rather than having \code{flashier} compute \code{Y2}, which involves explicitly
#'   forming the \eqn{n \times n} dense matrix \eqn{Y} and can be much slower and 
#'   even cause memory issues. 
#'
#' @return An initialized \code{\link{flash}} object (with no factors).
#'
#' @examples
#' # Create \eqn{n \times p} sparse matrix \eqn{X}, where \eqn{p} is much smaller than \eqn{n}.
#' X <- Matrix::Matrix(rbinom(1e8, 1, 0.1), ncol = 1e3, sparse = TRUE)
#' 
#' # Provide a low-rank matrix representation for the input \code{data}.
#' dat <- list(U = X, D = rep(1 / ncol(X), ncol(X)), V = X)
#'
#' # Calculate \code{Y2} externally and supply it to \code{flash_init}.
#' Y2_val <- sum((Matrix::crossprod(X) / ncol(X))^2)
#' fit.init <- flash_init(dat, var_type = 0, Y2 = Y2_val)
#'
#' @export
#'
flash_init <- function(data, S = NULL, var_type = 0L, S_dim = NULL, Y2 = NULL) {
  flash <- set.flash.data(data, S = S, S.dim = S_dim, var.type = var_type)
  if(!is.null(Y2)) {
    flash <- set.Y2(flash, Y2)
  }

  if (is.var.type.zero(flash) && !is.tau.simple(flash)) {
    flash$R <- flash$Y
  }

  # Precomputations.
  if (is.tau.simple(flash)) {
    flash$n.nonmissing <- init.n.nonmissing(flash, get.R2.n(flash))
  } else if (is.var.type.zero(flash)) {
    flash$log.2pi.s2 <- init.log.2pi.s2(get.given.tau(flash))
  } else if (is.var.type.kronecker(flash)) {
    flash$kron.nonmissing <- init.kron.nonmissing(flash)
  }

  # Calculate initial residual variances and ELBO.
  flash <- init.tau(flash)
  flash$obj <- calc.obj(flash)

  # Fields used to fix factors.
  flash$fix.dim <- list()
  flash$fix.idx <- list()

  # Some 'hidden' global options.
  flash$use.fixed.to.est.g <- FALSE

  # Fields that are no longer used.
  flash$nonmissing.thresh <- rep(0, get.dim(flash))
  flash$exclusions <- list()

  flash <- wrapup.flash(flash, output.lvl = 3L)
  flash <- flash_set_verbose(flash, verbose = 1L)

  tol <- sqrt(.Machine$double.eps) * prod(get.dims(flash_fit(flash)))
  flash <- flash_set_conv_crit(flash, flash_conv_crit_elbo_diff, tol)

  return(flash)
}

# Precomputations for estimating variance and calculating objective -----------

init.n.nonmissing <- function(flash, n) {
  Z    <- get.nonmissing(flash)
  dims <- get.dims(flash)

  if (identical(Z, 1)) {
    n.nonmissing <- rep(prod(dims[-n]), dims[n])
  } else {
    n.nonmissing <- nmode.prod.r1(Z, r1.ones(flash), n)
  }

  if (store.R2.as.scalar(flash))
    n.nonmissing <- sum(n.nonmissing)

  return(n.nonmissing)
}

init.kron.nonmissing <- function(flash) {
  return(lapply(get.est.tau.dim(flash),
                function(n) init.n.nonmissing(flash, n)))
}

init.log.2pi.s2 <- function(tau) {
  return(sum(log(2 * pi / tau[tau > 0])))
}
